//
//  ip.swift
//  LeetCode91
//
//  Created by gaozejian on 2019/1/2.
//  Copyright © 2019 solordreams. All rights reserved.
//

import UIKit

class ip: NSObject {
/*
     https://blog.csdn.net/zhangliangzi/article/details/52554439
     https://zhidao.baidu.com/question/576079521.html
     为什么需要三次握手
     https://www.cnblogs.com/laowz/p/6947539.html
     
     https://www.zhihu.com/question/24853633
     
     https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ
     
     tcp 首包 包括 :
                     源端口，接收端口，
                     序列号（seq），包括确认号（ACK）
                     ,首部偏移量
                     标志位包括 syn(同步标志位),ack(确认标志位),fin(结束标志位),reset(重置)
                     数据data
     TCP 是一种高效的稳定的通信方式(相对于UDP)
         那么提高稳定性 就需要确认信道的通畅.于是就有了"三次握手"来确保信道通畅
         通过判断数据的完整性来判断 通道的通畅
         握手过程
         于是 第一次请求链接 发送同步请求 syn = 1 同时对当前数据进行编码 seq = 随机数 (自所以是随机数 是因为第一次链接出于0位) 此时客户端出去激活状态
             第二次握手,服务器收到 syn 同步请求后,ACK标志未确认,同时得到y客户端发送的seq = 随机数,(这是服务端需要告知客户端我收到最后数据长度是多少,及 seq + length 此时length = 1 ),那么确认的 ack = seq + 1 , 服务端也需要给客户端发送自己的序列号让其验证数据的准确性  seq = 随机数  此时服务端为激活状态
             第三次握手,客户端收到服务器的请求, 拿到 服务器返回的确认码ack 与客户端第一次发送的seq + 1 进行验证 如果相等则表示通信正常收到的数据完整,此时客户端 发送ACK 确认标志位,同是 取得服务端发回的seq 赋值给ack = 服务端的seq + 1, 服务器收到到 连通
     
     其实本身也可以通过四次握手实现 及 第二次拆分为两次 (1) 确认标志位ACK 同时保存 客户端的seq
                                               (2) 发送syn 同步,同时发送 ack = seq(客户端的seq) + 1   以及自己的seq = 随机数
     因为单纯的ACK 不用确认应答,如果应答就会出现死循环,所以可以合并一起,即不是4次握手时三次 握手 实现高效
     
     如果是两次握手  即使只有前两次,只能确认,客户端知道了服务器能收到客户端的完整数据 即 客户端到>>>服务端 信道是通畅的
                因为服务端没有收到 ACK的确认状态码,即服务器不能确认 服务器到>>>客户端的信道是否通畅
                因为tcp 为双向通道 2次握手不能确认信道的通畅 也就是去了意义
     
     
     如果三次握手出现异常会怎样
           第一次握手 中途丢失,服务器未收到   那么客户端会周期性的重新发送, 一直到客户端 收到第二次握手的确认ACK
           第二次握手 中途丢失,没能达到客户端, 那么服务器会周期行的重新发送,一直到服务端 收到s第三次的握手确认ACK
           第三次握手 中途丢失,没能达到服务端
     此时情况分为: 客户端为接通状态(能发送能接收),服务端不能发送数据
               a. 假设此时双方都不传递数据,那么服务器会一直发送第二次握手,直到收到客户端的ACK确认
               b. 加入客户端此时发送数据,服务端收到 DATA + ACK ,服务端状态变为可通信,一切正常
               c. 如果服务端想发送数据 无法发送,服务端只能重复第二次握手,直到收到客户端的第三次握手
     
     
     两次握手还有另一种情况出现: 第一次握手a丢失,未到达服务器,被网络阻塞,这是客户端在此发起第一次握手b,b到达服务器然后c数据传输结束.断开.这是链接a这个无效链接又过来
     服务器应答,tcp 接通,但是数据已经传输结束,没有数据传输,不能结束,s信道被浪费占用.
     
     
     TCP 断开4次挥手
     
     由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，
     
     收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。
     
     上面可以理解为,双工信道,两方都需要 一次fin 和ack确认 所以为4 次 如下:
     第一次挥手: 客户端发起结束FIN
     第二次挥手:服务端收到客户端的fin 并应答 ACK 状态码
     第三次挥手:服务端发起结束Fin
     第四次挥手:客户端应答ACK 确认码,并且2ms 以后报文失效
     
    挥手为什么是4次不是3次
       按照握手的思路,挥手的第二次和第三次 发送ack + fin 可以一起发送,岂不是更高效么, 也就实现的三次挥手
     但是这样会出现问题就是:
                       客户端没东西发送了 发起fin 请求 但是此时客户端还是能接收数据的,
                       此时服务端如果没有数据发送了当然 可以合并到一起,但是如果有东西发送呢,如果二和三一起发送,那么服务端就不能发送数据了,
                       考虑到此 先 发送应答ack 客户端不在发数据, 这是如果服务端如果有数据发送那么可以继续发送,发送完毕以后,这是结束fin 等待应答 结束
     
     为什么会有time_wait 在第三次握手完成以后发送第四次握手,
                      如果服务端没有收到 客户端第四次挥手的ack 那么 服务端会周期性发送第三次挥手fin , 如果客户端已经释放那么服务器将不能正常关闭
                      如果有时间延迟那么可以确保服务器多次发起第三次握手确保正常退出
     
     */
    
    
    
    /*
     https://zhuanlan.zhihu.com/p/24913080
     
     HTTP 协议
     http 是文本传输协议,属于应用层,用于客户端向服务器获取资源或者发送资源,并且服务器进行相应
     其工作流程大概如下:
            1.根据域名进行DNS 得到ip
                 (1),搜索自身的DNS缓存,如果没有就去系统和磁盘里面找,如果还没有就发起请求得到ip
            2.拿到ip 以后进行tcp 3次握手如上
            3.握手成功以后发送http请求,数据传输完成以后
            4,四次挥手断开连接
     HTTP 由 请求 和 响应 两部分组成
     HTTP请求又由
                 (1)状态行: 请求方法(get),+ 路径  + 协议版本号组成
                 (2)请求头:  cookie 和ua 等主机信息
                 (3)请求体: 传输内容 如post的请求参数
     
     http 响应 由
                 (1)状态行: 状态码如 302 404
                 (2)响应头:一些基本信息
                 (3)响应体:返回的内容
     
     
     常见状态码:
             状态码一般由3位构成：
             
             1xx : 表示请求已经接受了，继续处理。
             2xx : 表示请求已经处理掉了。
             3xx : 重定向。
             4xx : 一般表示客户端有错误，请求无法实现。
             5xx : 一般为服务器端的错误。
             比如常见的状态码：
             
             200 OK 客户端请求成功。
             301 Moved Permanently 请求永久重定向。
             302 Moved Temporarily 请求临时重定向。
             304 Not Modified 文件未修改，可以直接使用缓存的文件。
             400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
             401 Unauthorized 请求未经授权，无法访问。
             403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。
             404 Not Found 请求的资源不存在，比如输入了错误的URL。
             500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
             503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。
     
     
    其中 get 和 post 的区别:
          1.参数get 放在状态行里面拼接在URL后面,post 放在请求题里面
          2.get的请求参数大小有限制
          3.get 明文 不安全
          4,get可以缓存当做书签,post可以缓存 但是不能当做书签
     
     关于cookie
        因为http 是无状态无连接的 所以断开以后在请求服务器不能使识别是否为同一用户,
        于是就用服务器给客户端一个cookie(服务端生成一个sessionID 放到cookie里面) 里面有一些基本信息,客户端每次请求的时候带上cookie,服务器通过cookie识别是否为统一用户
     关于 持久链接 keep-Alive 和 无状态无连接
         默认开启keep-Alive  这样不用每次请求都进行tcp三次握手
     关于GET的缓存
         如果数据没有变的话,服务器会根据第一次返回的报文 last - modified 进行判断是否需要更新,否则直接使用缓存
     */
    
    /*
     https://zhuanlan.zhihu.com/p/22142170
     https://blog.csdn.net/qq_23167527/article/details/80614454
     HTTPS :
           1.客户端发起ssl 请求,
           2.服务端向客户端发送CA证书
           3.客户端验证CA证书,并且从CA中取出 注册CA时的公钥,生成对称秘钥,对对称秘钥加密,发送给服务器
           4,服务器收到请求,用注册CA时的私钥 解密加密信息 得到 对称秘钥
           然后通信通过对称秘钥加密信息 解密信息
     
     第一种用法：公钥加密，私钥解密。---用于加解密
     第二种用法：私钥签名，公钥验签。---用于签名
     

     */
    
    /*
     https://www.douban.com/group/topic/114519182/
     
     链接：https://www.zhihu.com/question/29637351/answer/534704474
     来源：知乎
     https://yunxin.163.com/dev-blog?from=zhihu&utm_source=zhihu&utm_medium=ques&utm_campaign=seo&utm_content=video-ques
     网易云
     
     socket是位于传输层的网络编程了，一般用于需要自己定义应用层的协议的应用程序，如果已经有了成熟的应用层协议，比如http等，
     
     其中的传输层就是 TCP/IP 所在的地方，而你平时通过代码编写的应用程序大多属于应用层范畴，socket 在这里起到就是连接应用层与传输层的作用。socket 的诞生是为了应用程序能够更方便的将数据经由传输层来传输，所以它本质上就是对 TCP/IP 的运用进行了一层封装，然后应用程序直接调用 socket API 即可进行通信。那么它是如何工作的呢？它分为 2 个部分，服务端需要建立 socket 来监听指定的地址，然后等待客户端来连接。而客户端则需要建立 socket 并与服务端的 socket 地址进行连接。
     
     作者：网易云信
     //聊天室介绍
     https://zhuanlan.zhihu.com/p/24475299
     LCSStudioSocketController >>  LCSAsyncSocket
     1. 通过HTTP 请求 获取 socket 需要的 host(域名或ip) 和 port(端口号8080)
     2.初始化socket抽象类,默认端口赋值 然后socket 懒加载初始化 异步线程 链接socket
        代理方法f收到回调 socket 链接成功, 这时候在代理方法中 进行身份验证(将用户的个人信息发送过去),
         身份验证过程:
                   身份信息(从字典>string > nsdata)转换成nsdata, 准换成 byte类型,获取内容长度,
                   NSData.length + 首部.length  得到分包的长度
                   然后把包首 结构体 + n数据内容  拼接成完整的 NSData包数据
                     包首 如下
                     SocketHeader header = {
                                     CFSwapInt32HostToBig(packLen), //包的长度
                                     CFSwapInt16HostToBig([self headerLength]),//包首的长度
                                     CFSwapInt16HostToBig(LCS_VERSION),//版本号
                                     CFSwapInt32HostToBig((uint32_t)command),//用来判断消息类型,如验证身份,新消息,加入房间,退出房间,或者是心跳数据
                                     CFSwapInt32HostToBig((uint32_t)seq)//聊天室的id
                                     };
                   然后通过socket 把数据写入传给服务器 tag 为自己定义的表示 用来区分类型
                   [self.socket writeData:requestData withTimeout:WRITE_TIME_OUT tag:LCS_DEFAULT_TAG];
                   回调UI控制器,提示连接成功
        2.1 如果连接失败 根据具体情况 如果是超时,意外断开,那么开始重新连接 达到重连次数,那么不再连接
     
     3. 接下来 就是通过 socket didReadData  didWriteData 两个代理方法接受和发送数据
     3.1 接收数据:
          - (void)socket:(LCSAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag
         拿到数据以后首先进行解包
          取出数据的包首,b拿到包的长度 然后和接收到的data 长度进行比较, 如果想等就是完整包,
          完整包对消息类型判断:
                     1.身份验证成功则是 开始心跳,然后更新用户数据添加房间号,进行加入房间请求 socket发送
                     2.如果其他的几种情况如: 新消息,加入房间,等则直接处理包数剧
     完整包解析:
        取出包首,拿到聊天室id 判断是否为当前聊天室,如果不是 return
        如果是当前聊天室 把数据解析json 通过代理方法把数据传给应用界面
     
     如果是有分包数据 当前为第一次接收:
           创建 数据接收对象 将包长和数据类型 以及当前数据复制给他,
     如果收到的是分包的第二包以及以后的数据
          如果新数据添加以后 数据完整,那么进行数据解包,如果数据超过了(异常)
     //如果数据异常:粘包现象
           截取多余的数据,如果该数据长度 小于 包首的长度,那么直接舍弃
           如果大于包首长度,则按照有分包的数据处理
     
     
     */
    
    /*
     AFNetworing 线程分析
     https://www.jianshu.com/p/b5c27669e2c1
     
     通过NSOperation 实现控制 监听网络请求的 创建、进行、取消、完成、暂停恢复、异常等问题及状态
     */
}
